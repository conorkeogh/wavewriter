# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_examples_regular.ipynb.

# %% auto 0
__all__ = ['plot_waveforms', 'generate_tonic', 'generate_burst_boston', 'exponential_decay', 'objective', 'generate_burst_abbott']

# %% ../nbs/04_examples_regular.ipynb 2
from nbdev.showdoc import *
import numpy as np
from scipy.optimize import minimize
from math import exp, pow

from matplotlib import pyplot as plt
import seaborn as sns
import time

# %% ../nbs/04_examples_regular.ipynb 7
def plot_waveforms(t, v):
    '''
    Generate waveform plot
    Simulate effect of sending to DAC
    
    For every point after first: duplicate previous amplitude value at new timepoint
    This allows simulating step change at each timepoint
    '''
    new_v = [0, 0, v[0]]
    new_t = [-50, t[0], t[0]]
    
    for idx, v_ in enumerate(v[1:]):
        # Add old value at new timepoint
        new_v.append(new_v[-1])
        new_t.append(t[idx+1])
        
        # Add new value at new timepoint
        new_v.append(v_)
        new_t.append(t[idx+1])
        
    # Plot figures
    fig, ax = plt.subplots()
    ax.plot(new_t, new_v, 'k.')
    ax.plot(new_t, new_v, 'k')
    
    ax.set(
        xlabel = 'Time ($\mu$s)',
        ylabel = 'Amplitude (mA)'
    )
    
    sns.despine(offset = 10, trim=True)

# %% ../nbs/04_examples_regular.ipynb 12
# Generate tonic stimulation waveform
def generate_tonic(
    amplitude: float, # Amplitude of square wave; mA
    frequency: int, # Number of square waves per second; Hz
    pulsewidth: int, # Width of pulses; us
    biphasic: bool = True # Whether to include charge balancing phase; bool
) -> (np.ndarray, np.ndarray):
    '''
    Generate tonic square wave stimulation
    Args:
        amplitude: float; amplitude of square waves (mA)
        frequency: int; number of square waves per second (Hz)
        pulsewidth: int; width of pulses (us)
        biphasic: bool, default True; whether pulses should have biphasic component
    Returns:
        v: ndarray; output at each timepoint (mA)
        t: ndarray; correspondong timepoints (us)
    '''
    # Start with stimulation on at t=0
    v = np.array([])
    t = np.array([])
    
    # Get period between pulses
    period = 1000000 / frequency # Period in microseconds
    
    # Get interval between pulses
    if biphasic == True:
        interval = period - (pulsewidth * 2)
    else:
        interval = period - pulsewidth
        
    # Generate five pulses (repeating):
    for pulse in range (1):
        # Start stimulation
        v = np.concatenate((v, np.ones(int(pulsewidth/10), dtype=int)*amplitude))
            
        # If biphasic: add biphasic pulse then stop
        if biphasic == True:
            # Add negative phase
            v = np.concatenate((v, np.ones(int(pulsewidth/10), dtype=int)*-amplitude))
            
        # Add interval before next pulse
        v = np.concatenate((v, np.zeros(int(interval/10), dtype=int)))
        
    # Get time
    t = np.linspace(0, len(v)*10, num=len(v))
        
    return v, t

# %% ../nbs/04_examples_regular.ipynb 19
# Generate Boston burst waveform
def generate_burst_boston(
    amplitude: float, # Amplitude of burst; mA
    numpulses: int, # Number of pulses in burst
    intraburst: int, # Frequency of pulses in burst; Hz
    interburst: int, # Frequency of bursts; Hz
    pulsewidth: int # Width of pulses in burst; us
) -> (np.ndarray, np.ndarray):
    '''
    Generate Boston burst waveform
    Args:
        amplitude: float; amplitude of burst (mA)
        numpulses: int; number of pulses in burst
        intraburst: int; frequency of pulses within burst (Hz)
        interburst: int; frequency of bursts (Hz)
        pulsewidth: int; width of pulses (us)
    Returns:
        v: ndarray; output at each timepoint (mA)
        t: ndarray; corresponding timepoints (us)
    '''
    # Create lists; start stimulation at t=0
    v = np.array([])
    t = np.array([])
    
    # Get period and interval between pulses
    period_intra = 1000000 / intraburst # Period in microseconds
    interval_intra = period_intra - (pulsewidth * 2)
    
    # Get period and interval between bursts
    burst_duration = ((pulsewidth * 2) + interval_intra) * numpulses
    period_inter = 1000000 / interburst
    interval_inter = period_inter - burst_duration
    
    # Generate three bursts
    for burst in range (1):
        # Generate pulses
        for pulse in range(numpulses):
            # Start stimulation
            v = np.concatenate((v, np.ones(int(pulsewidth/10), dtype=int)*amplitude))
            
            # Add biphasic pulse
            v = np.concatenate((v, np.ones(int(pulsewidth/10), dtype=int)*-amplitude))
            
            # Add interval before next pulse
            v = np.concatenate((v, np.zeros(int(interval_intra/10), dtype=int)))
            
        # Add interval before next burst
        v = np.concatenate((v, np.zeros(int(interval_inter/10), dtype=int)))
        
    # Get time
    t = np.linspace(0, len(v)*10, num=len(v))
        
    return v, t

# %% ../nbs/04_examples_regular.ipynb 23
# a set to amplitude / 2; k determined numerically
def exponential_decay(x, a, k):
    return a * np.exp(-k * x)

# Objective function: find k s.t. AUC exponential = AUC pulses
def objective(k, x, a, target):
    auc_recovery = np.abs(np.sum(exponential_decay(x,a,k))) 
    val = np.abs(auc_recovery - target)
    #print(f"{k}: {auc_recovery}; {target}; {val}")
    return val

# %% ../nbs/04_examples_regular.ipynb 24
# Generate Abbott burst waveform
def generate_burst_abbott(
    amplitude: float, # Amplitude of burst; mA
    intraburst: int, # Frequency of pulses within burst; Hz
    interburst: int, # Frequency of bursts; Hz
    pulsewidth: int # Width of pulses within burst (us)
) -> (np.ndarray, np.ndarray):
    '''
    Generate Abbott burst waveform
    Args:
        amplitude: float; amplitude of burst (mA)
        intraburst: int; frequency of pulses within burst (Hz)
        interburst: int; frequency of bursts (Hz)
        pulsewidth: int; width of pulses (us)
    Returns:
        v: ndarray; output at each timepoint (mA)
        t: ndarray; corresponding timepoints (us)
    '''
    # Create lists; start stimulation at t=0
    v = np.array([])
    t = np.array([])
    
    # Get period + interval between pulses
    period_intra = 1000000 / intraburst # Period in microseconds
    interval_intra = period_intra - pulsewidth
    
    # Get period + interval between bursts
    burst_duration = (pulsewidth + interval_intra) * 5
    period_inter = 1000000 / interburst
    interval_inter = period_inter - burst_duration
    
    # Generate pulses
    for pulse in range(4):
        # Start stimulation
        v = np.concatenate((v, np.ones(int(pulsewidth/10), dtype=int)*amplitude))
        
        # Add interval before next pulse
        v = np.concatenate((v, np.zeros(int(interval_intra/10), dtype=int)))
        
    # Add last pulse - no interval after
    v = np.concatenate((v, np.ones(int(pulsewidth/10), dtype=int)*amplitude))
    
    # Add recovery phase
    t_ = np.linspace(0, 5000, num=500)
    
    # Get value to recover
    target = np.abs(np.sum(v))
    
    # Optimise parameters to match this 
    x0 = 0.001
    res = minimize(objective, x0,
                  method='nelder-mead',
                  args=(t_, -amplitude*0.25, target)
                  )
    
    # Get optimal value
    k = res.x
    
    # Get exponential recovery
    v_recovery = exponential_decay(t_, -amplitude*0.25, -res.x)
    
    # Add to values
    v = np.concatenate((v, v_recovery))
        
    # Add interval before next burst
    v = np.concatenate((v, np.zeros(int(interval_inter/10), dtype=int)))
    
    # Get time
    t = np.linspace(0, len(v)*10, num=len(v))
    
    return v, t
