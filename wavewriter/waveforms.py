# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_examples.ipynb.

# %% auto 0
__all__ = ['plot_waveforms', 'generate_tonic', 'generate_burst_boston', 'exponential_decay', 'objective', 'generate_burst_abbott',
           'generate_sine', 'generate_russian', 'generate_wavelet', 'generate_wavelet_modulated']

# %% ../nbs/04_examples.ipynb 2
from nbdev.showdoc import *
import numpy as np
from scipy.optimize import minimize
from math import exp, pow

from matplotlib import pyplot as plt
import seaborn as sns
import time

# %% ../nbs/04_examples.ipynb 7
def plot_waveforms(t, v):
    '''
    Generate waveform plot
    Simulate effect of sending to DAC
    
    For every point after first: duplicate previous amplitude value at new timepoint
    This allows simulating step change at each timepoint
    '''
    new_v = [0, 0, v[0]]
    new_t = [-50, t[0], t[0]]
    
    for idx, v_ in enumerate(v[1:]):
        # Add old value at new timepoint
        new_v.append(new_v[-1])
        new_t.append(t[idx+1])
        
        # Add new value at new timepoint
        new_v.append(v_)
        new_t.append(t[idx+1])
        
    # Plot figures
    fig, ax = plt.subplots()
    ax.plot(new_t, new_v, 'k.')
    ax.plot(new_t, new_v, 'k')
    
    ax.set(
        xlabel = 'Time ($\mu$s)',
        ylabel = 'Amplitude (mA)'
    )
    
    sns.despine(offset = 10, trim=True)

# %% ../nbs/04_examples.ipynb 12
# Generate tonic stimulation waveform
def generate_tonic(
    amplitude: float, # Amplitude of square wave; mA
    frequency: int, # Number of square waves per second; Hz
    pulsewidth: int, # Width of pulses; us
    biphasic: bool = True # Whether to include charge balancing phase; bool
) -> (np.ndarray, np.ndarray):
    '''
    Generate tonic square wave stimulation
    Args:
        amplitude: float; amplitude of square waves (mA)
        frequency: int; number of square waves per second (Hz)
        pulsewidth: int; width of pulses (us)
        biphasic: bool, default True; whether pulses should have biphasic component
    Returns:
        v: ndarray; output at each timepoint (mA)
        t: ndarray; correspondong timepoints (us)
    '''
    # Set timestep
    timestep = 5 # us
    
    # Start with stimulation on at t=0
    v = np.array([])
    t = np.array([])
    
    # Get period between pulses
    period = 1000000 / frequency # Period in microseconds
    
    # Get interval between pulses
    if biphasic == True:
        interval = period - (pulsewidth * 2)
    else:
        interval = period - pulsewidth
        
    # Generate five pulses (repeating):
    for pulse in range (1):
        # Start stimulation
        v = np.concatenate((v, np.ones(int(pulsewidth/timestep), dtype=int)*amplitude))
            
        # If biphasic: add biphasic pulse then stop
        if biphasic == True:
            # Add negative phase
            v = np.concatenate((v, np.ones(int(pulsewidth/timestep), dtype=int)*-amplitude))
            
        # Add interval before next pulse
        v = np.concatenate((v, np.zeros(int(interval/timestep), dtype=int)))
        
    # Get time
    t = np.linspace(0, len(v)*timestep, num=len(v))
        
    return v, t

# %% ../nbs/04_examples.ipynb 19
# Generate Boston burst waveform
def generate_burst_boston(
    amplitude: float, # Amplitude of burst; mA
    numpulses: int, # Number of pulses in burst
    intraburst: int, # Frequency of pulses in burst; Hz
    interburst: int, # Frequency of bursts; Hz
    pulsewidth: int # Width of pulses in burst; us
) -> (np.ndarray, np.ndarray):
    '''
    Generate Boston burst waveform
    Args:
        amplitude: float; amplitude of burst (mA)
        numpulses: int; number of pulses in burst
        intraburst: int; frequency of pulses within burst (Hz)
        interburst: int; frequency of bursts (Hz)
        pulsewidth: int; width of pulses (us)
    Returns:
        v: ndarray; output at each timepoint (mA)
        t: ndarray; corresponding timepoints (us)
    '''
    # Set timestep
    timestep = 5
    
    # Create lists; start stimulation at t=0
    v = np.array([])
    t = np.array([])
    
    # Get period and interval between pulses
    period_intra = 1000000 / intraburst # Period in microseconds
    interval_intra = period_intra - (pulsewidth * 2)
    
    # Get period and interval between bursts
    burst_duration = ((pulsewidth * 2) + interval_intra) * numpulses
    period_inter = 1000000 / interburst
    interval_inter = period_inter - burst_duration
    
    # Generate three bursts
    for burst in range (1):
        # Generate pulses
        for pulse in range(numpulses):
            # Start stimulation
            v = np.concatenate((v, np.ones(int(pulsewidth/timestep), dtype=int)*amplitude))
            
            # Add biphasic pulse
            v = np.concatenate((v, np.ones(int(pulsewidth/timestep), dtype=int)*-amplitude))
            
            # Add interval before next pulse
            v = np.concatenate((v, np.zeros(int(interval_intra/timestep), dtype=int)))
            
        # Add interval before next burst
        v = np.concatenate((v, np.zeros(int(interval_inter/timestep), dtype=int)))
        
    # Get time
    t = np.linspace(0, len(v)*timestep, num=len(v))
        
    return v, t

# %% ../nbs/04_examples.ipynb 23
# a set to amplitude / 2; k determined numerically
def exponential_decay(x, a, k):
    return a * np.exp(-k * x)

# Objective function: find k s.t. AUC exponential = AUC pulses
def objective(k, x, a, target):
    auc_recovery = np.abs(np.sum(exponential_decay(x,a,k))) 
    val = np.abs(auc_recovery - target)
    #print(f"{k}: {auc_recovery}; {target}; {val}")
    return val

# %% ../nbs/04_examples.ipynb 24
# Generate Abbott burst waveform
def generate_burst_abbott(
    amplitude: float, # Amplitude of burst; mA
    intraburst: int, # Frequency of pulses within burst; Hz
    interburst: int, # Frequency of bursts; Hz
    pulsewidth: int # Width of pulses within burst (us)
) -> (np.ndarray, np.ndarray):
    '''
    Generate Abbott burst waveform
    Args:
        amplitude: float; amplitude of burst (mA)
        intraburst: int; frequency of pulses within burst (Hz)
        interburst: int; frequency of bursts (Hz)
        pulsewidth: int; width of pulses (us)
    Returns:
        v: ndarray; output at each timepoint (mA)
        t: ndarray; corresponding timepoints (us)
    '''
    # Set timestep
    timestep = 5 # us
    
    # Create lists; start stimulation at t=0
    v = np.array([])
    t = np.array([])
    
    # Get period + interval between pulses
    period_intra = 1000000 / intraburst # Period in microseconds
    interval_intra = period_intra - pulsewidth
    
    # Get period + interval between bursts
    burst_duration = (pulsewidth + interval_intra) * 5
    period_inter = 1000000 / interburst
    interval_inter = period_inter - burst_duration
    
    # Generate pulses
    for pulse in range(4):
        # Start stimulation
        v = np.concatenate((v, np.ones(int(pulsewidth/timestep), dtype=int)*amplitude))
        
        # Add interval before next pulse
        v = np.concatenate((v, np.zeros(int(interval_intra/timestep), dtype=int)))
        
    # Add last pulse - no interval after
    v = np.concatenate((v, np.ones(int(pulsewidth/timestep), dtype=int)*amplitude))
    
    # Add recovery phase
    t_ = np.linspace(0, interval_inter, num=int(interval_inter/timestep))
    
    # Get value to recover
    target = np.abs(np.sum(v))
    
    # Optimise parameters to match this 
    x0 = 0.001
    res = minimize(objective, x0,
                  method='nelder-mead',
                  args=(t_, -amplitude*0.75, target)
                  )
    
    # Get optimal value
    k = res.x
    
    # Get exponential recovery
    v_recovery = exponential_decay(t_, -amplitude*0.75, res.x)
    
    # Add to values
    v = np.concatenate((v, v_recovery))
        
    # Add interval before next burst
    #v = np.concatenate((v, np.zeros(int(interval_inter/5), dtype=int)))
    
    # Get time
    t = np.linspace(0, len(v)*timestep, num=len(v))
    
    return v, t

# %% ../nbs/04_examples.ipynb 29
# Generate sinusoidal waveform
def generate_sine(
    amplitude: float, # Amplitude of sine wave
    frequency: int, # Frequency of sine wave
    numcycles: int # Number of cycles to generate
) -> (np.ndarray, np.ndarray):
    '''
    Generate sinusoidal waveform
    Args:
        amplitude: float; maximal amplitude
        frequency: int; frequency of sinusoid
        numcycles: int; number of cycles to generate
    Returns:
        v: ndarray; output at each timepoint (mA)
        t: ndarray; corresponding timepoints (us)
    '''
    # Set timestep
    timestep = 5 # us
    
    # Get period for one cycle
    period = 1 / frequency
    num_samples = int((1000000 / frequency) / timestep) # 10us per sample
    
    # Get time
    t = np.linspace(0, period*numcycles, num=num_samples*numcycles)
    
    # Get sinusoid
    v = np.sin(2 * np.pi * frequency * t) * amplitude
    
    # Convert time to microseconds
    t = t * 1000000
    
    return v, t

# %% ../nbs/04_examples.ipynb 33
# Generate Russian waveform
def generate_russian(
    amplitude: float, # Amplitude of sinusoid; mA
    frequency_sine: int, # Frequency of sinusoid; Hz
    frequency_square: int, # Frequency of modulating square wave; Hz
    pulsewidth_square: int # Width of modulating square wave; us
) -> (np.ndarray, np.ndarray):
    '''
    Generate Russian waveform
    Sinusoidal waveform modulated by square waves
    Args:
        amplitude: float; amplitude of sinusoid (mA)
        frequency_sine: int; frequency of sinusoid (Hz)
        frequency_square: int; frequency of modulating square wave (Hz)
        pulsewidth_square: int; width of modulating square wave (us)
    Returns:
        v: ndarray; output at each timepoint (mA)
        t: ndarray; corresponding timepoints (us)
    '''
    # Set timestep
    timestep = 5 # us
    
    # Get period and interval
    period_square = 1000000 / frequency_square
    interval_square = period_square - pulsewidth_square
    num_samples = pulsewidth_square / timestep # 5us per sample
    
    # Get cycles per window
    cycles_per_window = frequency_sine / frequency_square
    
    # Get time
    t = np.linspace(0, pulsewidth_square/1000000, num=int(num_samples))
    
    # Get sinusoid
    v = np.sin(2 * np.pi * frequency_sine * t) * amplitude
    
    # Add interval
    v = np.concatenate((v, np.zeros(int(interval_square/timestep), dtype=int)))
    
    # Get total time
    t = np.linspace(0, len(v)*timestep, num=len(v))
    
    return v, t

# %% ../nbs/04_examples.ipynb 37
# Generate wavelet waveform
def generate_wavelet(
    amplitude: float, # Amplitude of sinusoid: mA
    frequency_sine: int, # Frequency of sinusoid; Hz
    frequency_wavelet: int, # Frequency of wavelets; Hz
    wavelet_sigma: int, # Width of wavelet; us
) -> (np.ndarray, np.ndarray):
    '''
    Generate wavelet waveform
    Sinusoidal waveform modulated by Gaussian
    Args:
        amplitude: float; amplitude of sinusoid (mA)
        frequency_sine: int; frequency of sinusoid (Hz)
        frequency_wavelet: int; frequency of wavelets (Hz)
        wavelet_width: int; width of wavelet (us)
    Returns:
        v: ndarray; output at each timepoint (mA)
        t: ndarray; corresponding timepoints (us)
    '''
    # Set timestep
    timestep = 5 # us
    
    # Get total length
    period_wavelet = 1 / frequency_wavelet
    num_samples = int((1000000 / frequency_wavelet) / timestep) # 5us per sample
    t = np.linspace(0, period_wavelet, num=int(num_samples))
    
    # Get sinusoid over total duration
    v = np.sin(2 * np.pi * frequency_sine * t) * amplitude
    
    # Get Gaussian over total duration
    midpoint = period_wavelet/2
    wavelet_sigma = wavelet_sigma / 1000000 # Convert to us
    wavelet = np.exp(-((t - midpoint)**2) / (2 * (wavelet_sigma**2)))
    
    # Modulate sinusoid with Gaussian
    v = v * wavelet
    
    # Convert time to microseconds
    t = t * 1000000
    
    return v, t

# %% ../nbs/04_examples.ipynb 41
# Generate modulated wavelet waveform
def generate_wavelet_modulated(
    amplitude: float, # Amplitude of sinusoid: mA
    frequency_sine: int, # Frequency of sinusoid; Hz
    frequency_wavelet: int, # Frequency of wavelets; Hz
    wavelet_sigma: int, # Width of wavelet; us
) -> (np.ndarray, np.ndarray):
    '''
    Generate wavelet waveform
    Sinusoidal waveform modulated by Gaussian
    Args:
        amplitude: float; amplitude of sinusoid (mA)
        frequency_sine: int; frequency of sinusoid (Hz)
        frequency_wavelet: int; frequency of wavelets (Hz)
        wavelet_width: int; width of wavelet (us)
    Returns:
        v: ndarray; output at each timepoint (mA)
        t: ndarray; corresponding timepoints (us)
    '''
    # Set timestep
    timestep = 5 # us
    
    # Get total length
    period_wavelet = 1 / frequency_wavelet
    num_samples = int((1000000 / frequency_wavelet) / timestep) # 5us per sample
    t = np.linspace(0, period_wavelet, num=int(num_samples))
    
    # Get sinusoid over total duration
    v = np.sin(2 * np.pi * frequency_sine * t) * amplitude
    
    # Get Gaussian over total duration
    midpoint = period_wavelet/2
    wavelet_sigma = wavelet_sigma / 1000000 # Convert to us
    wavelet = np.exp(-((t - midpoint)**2) / (2 * (wavelet_sigma**2)))
    
    # Get modulating sinusoid
    modulating_sine = np.sin(2 * np.pi * frequency_wavelet * t)*(amplitude/2)
    
    # Modulate with sinusoid
    v = v + modulating_sine
    
    # Modulate sinusoid with Gaussian
    v = v * wavelet
    
    # Convert time to microseconds
    t = t * 1000000
    
    return v, t
